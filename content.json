{"meta":{"title":"phoenix's blog","subtitle":"phoenix","description":"acm","author":"hdy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-11","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-11","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-11","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"11-11","excerpt":""}],"posts":[{"title":"sort","text":"1.结构体1.只有结构体定义 12345struct node &#123; int a; float b; char job[20];&#125; 2.定义一个结构体变量1node acm; 3.结构体之间的赋值如果我有一个结构体node a，但是我想在定义一个结构体(node b)并且让这个新定义的结构体( b )里面的值都和之前的结构体 a相同 。 12node b;b=a; 4.结构体的引用12345678910struct node &#123;int sorce;char name[20] ;&#125;node chengjidan；int main()&#123; cin&gt;&gt;chengjidan.sorce&gt;&gt;chengjidan.name; cout&lt;&lt;\"name: \"&lt;&lt;chengjidan.name&lt;&lt;endl; cout&lt;&lt;\"sorce: \"&lt;&lt;chengjidan.sorce&lt;&lt;endl;&#125; 5.结构体的运算符重载2.sort简介：sort 排序函数是在 C++ 中的一个库函数，它所在的头文件 为 algrithm.h，它其实就是对快速排序算法的封装，只需要 一行代码即可实现快速排序 它的时间复杂度为 O(n∗log(n)) 形式：sort(参数一, 参数二，参数三） 使用范围: 数组结构体 sting 队列 vector…… 使用方法：对数组 a 从小到大排序 a[5]12345678```\\对数据类型 Y 排序 sort(地址 1，地址 2，less&lt;Y&gt;());//以Y为int为例 int a[5]=&#123;2,1,3,4,5&#125;; sort(a,a+5,less&lt;int&gt;()); //less&lt;int&gt;()升序 //greater&lt;int&gt;()降序 自己定义sort排序自定义排序 1234bool cmp(int a,int b)&#123; return a&lt;b; //从小到大排序 return a&gt;b; //从大到小排序 &#125;sort(a,a+n,cmp) 结构体排序 12345bool cmp1(node a,node b)&#123;//自定义排序函数if(a.grade!=b.grade) return a.grade&gt;b,grade;return a.id&lt;b.id;//按照id排序 ，a&lt;b表示升序 ，a&gt;b降序 &#125; sort(a,a+n,cmp1);&#125; 3.栈和队列栈和队列是一种特殊的线性表，其区别在于栈是先进后出像 一个瓶子，而队列是先进先出像排队 1stack &lt;int&gt; s;//定义一个int型 1s.push(2);// 把2从栈顶压 1s. pop ();//弹出栈顶元素 1s. empty ();//判断栈是否为 空 1s. size ();// 栈的大小 12s.top() ;//返回栈顶的元素，但不删除该元素 1234567q.empty() //如果队列为空返回true，否则返回falseq.size() // 返回队列中元素的个数q.pop() //删除队列首元素但不返回其值q.front() // 返回队首元素的值，但不删除该元素q.push() //在队尾压入新元素q.back() // 返回队列尾元素的值，但不删除该元素","path":"2019/11/17/sort/","date":"11-17","excerpt":"","tags":[{"name":"sort","slug":"sort","permalink":"http://yoursite.com/tags/sort/"}]},{"title":"Kruskal算法求最小生成树（模板）","text":"此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按代价从小到大排序； 把图中的n个顶点看成独立的n棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5;int f[maxn];struct node &#123; int u;int v;int w;&#125;edges[maxn];bool cmp(node a,node b)&#123; return a.w&lt;b.w; &#125; int find(int x)&#123; if(f[x]!=x) f[x]=find(f[x]); return f[x];&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) f[x]=y;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;edges[i].u&gt;&gt;edges[i].v&gt;&gt;edges[i].w; &#125; sort(edges,edges+m,cmp); int res=0,cnt=0; for(int i=0;i&lt;m;i++) &#123; int a=edges[i].u;int b=edges[i].v;int w=edges[i].w; a=find(a),b=find(b); if(a!=b) &#123; join(a,b); res+=w; cnt++; &#125; &#125; if(cnt &lt; n-1) cout&lt;&lt;\"impossible\"; else cout&lt;&lt;res;&#125;","path":"2019/11/15/s/","date":"11-15","excerpt":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"codeforces 597 div2 的D 题","text":"[Shichikuji and Power Grid]添加链接描述codeforces 597 div2 的D 题，题意：在一个二维平面上面，有n个城市，现在每个城市都没有电。你可以选择一些城市建发电站，代价是c[i]；你也可以给每个城市拉电线，给城市(i,j)之间拉电线的代价是(abs(x[i]-x[j])+abs(y[i]-y[j]))*(k[i]+k[j])。现在问你最少花费多少代价，能够使得全部城市都有电，输出方案。 思路：写的时候无限自闭，最后A了（感谢龙佬），其实思路很简单，就是把这个题变成最小生成树问题就行了，相当于把供电站自身的花费变成了超级远点到供电站的距离，然后套一下最小生成树模板，就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+10;#define ll long long ll f[maxn],r[maxn];typedef pair&lt;ll,ll&gt; pil;struct node &#123; ll x;int y; &#125;p[maxn];struct Node &#123; ll u, v, w;&#125;P[maxn];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;bool cmp2(pil a,pil b)&#123; return a.first &lt;b.first;&#125;ll find(ll x)&#123; return f[x]!=x?f[x]=find(f[x]):x;&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) f[x]=y;&#125; vector&lt;pil&gt; s,ss;int main()&#123; ll n,pos,co; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;co;P[i].u=i;P[i].v=0;P[i].w=co; &#125; for(int i=1;i&lt;=n;i++) cin&gt;&gt;r[i]; pos=n+1; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) &#123; ll mid=(abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y))*(r[i]+r[j]); P[pos].u=j,P[pos].v=i,P[pos++].w=mid; &#125; ll sum=0,a=0,b=0; sort(P+1,P+pos+1,cmp); for(int i=1;i&lt;=pos;i++) &#123; if(find(P[i].u)!=find(P[i].v)) &#123; join(P[i].u,P[i].v); sum+=P[i].w; if(P[i].u!=0&amp;&amp;P[i].v!=0) a++,s.push_back(make_pair(P[i].u,P[i].v)); else b++,ss.push_back(make_pair(P[i].u,P[i].v)); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; sort(ss.begin(),ss.end(),cmp2); for(int i=0;i&lt;ss.size();i++) &#123; ll a1 = ss[i].first, a2 = ss[i].second; if(a1) cout&lt;&lt;a1&lt;&lt;&quot; &quot;; else cout&lt;&lt;a2&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; for(int i=0;i&lt;s.size();i++) &#123; ll a1 = s[i].first, a2 = s[i].second; if (a1 &gt; a2) swap(a1, a2); cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl; &#125;&#125;","path":"2019/11/13/tree/","date":"11-13","excerpt":"","tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"线段树","text":"线段树模板 用于处理区间问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define ll long long#define dl double#define fo(i,a,b) for (int i=a;i&lt;=b;i++)#define println(x)&#123;printf(\":\\n\");for (int tmpi=1;tmpi&lt;=n;tmpi++)printf(\"%d \",x[i]);printf(\"\\n\");&#125;using namespace std;const int N=1e5+7;const int INF=0x3f3f3f3f;const int M=1e9+7;class poi&#123;public: ll l,r,sum,maxx,add,lc,rc;&#125;;class seg&#123;public: vector&lt;poi&gt; s; void bulid(ll x)&#123; if (s[x].lc) return; ll l=s[x].l,r=s[x].r,mid=(l+r)&gt;&gt;1; s.push_back((poi)&#123;l,mid,0,0,0,0,0&#125;); s[x].lc=s.size()-1; s.push_back((poi)&#123;mid+1,r,0,0,0,0,0&#125;); s[x].rc=s.size()-1;&#125;void pushdown(ll x)&#123; bulid(x); ll lc=s[x].lc,rc=s[x].rc; s[lc].add+=s[x].add; s[lc].sum+=s[x].add*(s[lc].r-s[lc].l+1); s[rc].add+=s[x].add; s[rc].sum+=s[x].add*(s[rc].r-s[rc].l+1); updata(x);&#125;void updata(ll x)&#123; s[x].add=0; s[x].sum=s[s[x].lc].sum+s[s[x].rc].sum; s[x].maxx=max(s[s[x].lc].maxx,s[s[x].rc].maxx);&#125;void add(ll x,ll l,ll r,ll t)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; s[x].sum+=t*(s[x].r-s[x].l+1); s[x].add+=t; s[x].maxx+=t; return; &#125; else&#123; pushdown(x); if (l&lt;=s[s[x].lc].r)&#123; add(s[x].lc,l,r,t); &#125; if (r&gt;=s[s[x].rc].l)&#123; add(s[x].rc,l,r,t); &#125; updata(x); &#125;&#125;ll query_sum(ll x,ll l,ll r)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; return s[x].sum; &#125; else&#123; pushdown(x); ll tmp=0; if (l&lt;=s[s[x].lc].r)&#123; tmp+=query_sum(s[x].lc,l,r); &#125; if (r&gt;=s[s[x].rc].l)&#123; tmp+=query_sum(s[x].rc,l,r); &#125; return tmp; &#125;&#125;ll query_max(ll x,ll l,ll r)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; return s[x].maxx; &#125; else&#123; pushdown(x); ll tmp=0; if (l&lt;=s[s[x].lc].r)&#123; tmp=max(tmp,query_max(s[x].lc,l,r)); &#125; if (r&gt;=s[s[x].rc].l)&#123; tmp=max(tmp,query_max(s[x].rc,l,r)); &#125; return tmp; &#125;&#125;&#125;tree;int n;int m;ll l,r,t;ll a;void read()&#123; scanf(\"%d\",&amp;n); tree.s.push_back((poi)&#123;1,n,0,0,0,0&#125;); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;a); tree.add(0,i,i,a); &#125; tree.add(0,1,2,4); cout&lt;&lt;tree.query_max(0,1,4); /*scanf(\"%d\",&amp;m);char ch[5];for (int i=1;i&lt;=m;i++)&#123; scanf(\"%s\",ch); if (ch[0]=='S')&#123; scanf(\"%lld%lld\",&amp;l,&amp;r); printf(\"%lld\\n\",tree.sum(0,l,r)); &#125; if (ch[0]=='A')&#123; scanf(\"%lld%lld%lld\",&amp;l,&amp;r,&amp;t); tree.add(0,l,r,t); &#125;&#125;*/&#125;int main()&#123; read(); return 0;&#125;","path":"2019/11/12/article-name/","date":"11-12","excerpt":"","tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/11/11/hello-world/","date":"11-11","excerpt":"","tags":[]}]}