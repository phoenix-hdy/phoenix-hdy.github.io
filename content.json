{"meta":{"title":"phoenix's blog","subtitle":"phoenix","description":"acm","author":"hdy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-11","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-11","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-11","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"11-11","excerpt":""}],"posts":[{"title":"2020牛客暑期多校训练营（第二场）","text":"A All with Pairs因为是si的前缀去匹配sj的后缀，正好，AC自动机的fail指针是由后缀指向前缀，我们只需要根据fail指针反向建图，然后在从根节点去遍历， 但是只有最长的才有贡献，所以要不断地更新他的长度，当一个点根据fail指针指向另一个点时，这时可以在res上加上临时的贡献这个时候是指si到sj的匹配和sj本身对自己的匹配，最后别忘记回溯。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889```#include &lt;bits/stdc++.h&gt;#define ll long long#define pii pair&lt;int,int&gt;#define se second#define fi first#define pb push_back#define mp make_pairusing namespace std;const int N = 1e6 + 10;const int mod =998244353;int n;struct ACtree &#123;int tr[N][26], tot;int e[N], fail[N],len[N],c[N];vector&lt;int&gt; q[N],g[N];stack&lt;pii&gt; st;ll res=0,ans=0;void insert(char *s,int x) &#123; int u = 0; for (int i = 1; s[i]; i++) &#123; if (!tr[u][s[i] - 'a']) tr[u][s[i] - 'a'] = ++tot; u = tr[u][s[i] - 'a']; len[u]=i;//u节点的长度 q[u].pb(x);//看看u这个点都属于哪个字符串 &#125; e[u]++;&#125;void build() &#123; queue&lt;int&gt; q; for (int i = 0; i &lt; 26; i++) if (tr[0][i]) q.push(tr[0][i]); while (q.size()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; i++) &#123; if (tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i], q.push(tr[u][i]); else tr[u][i] = tr[fail[u]][i]; &#125; &#125; for(int i=1;i&lt;=tot;i++) g[fail[i]].pb(i);&#125;void dfs(int u)//遍历&#123; for(int x:q[u]) &#123; st.push(mp(x,c[x]));//放入，回溯时会用到 res=(res-c[x]+mod)%mod; c[x]=1ll*len[u]*len[u]%mod; res=(res+c[x]+mod)%mod; &#125; ans=(ans+1ll*res*e[u]%mod)%mod; for(int x:g[u]) &#123; dfs(x);//将根据fail指针建图的点遍历； &#125; &#123; for(int x:q[u]) &#123; pii tmp = st.top(); st.pop(); res=((res-c[tmp.fi])+mod)%mod; c[tmp.fi]=tmp.se; res=(res+c[tmp.fi]+mod)%mod; &#125; &#125;&#125; ll begin() &#123; dfs(0); return ans; &#125;&#125; AC; // namespace ACchar s[N];int main() &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%s\", s + 1), AC.insert(s,i); scanf(\"%s\", s + 1); AC.build(); printf(\"%lld\", AC.begin()); return 0;&#125; B Boundary三个点可以确定一个圆心，因为毕竟过（0，0），所以只需要记录他的圆心，然后在找哪个圆心最多就行了(qrnb) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899```#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define read(x) scanf(\"%d\",&amp;x)typedef long long ll;typedef double dl;using namespace std; const int N=2e4+7;const int M=1e9+7;const int INF=0x3f3f3f3f; int n,m; struct poi&#123; ll x,y;&#125;pos[N]; ll cnt[N]; vector&lt;pair&lt;dl,dl&gt; &gt; ls; ll a,b,c,d,e,f; inline void getCenterPos(ll x2,ll y2,ll x3,ll y3)&#123; ll x1=0,y1=0; dl x=((y2-y1)*(y3*y3-y1*y1+x3*x3-x1*x1)-(y3-y1)*(y2*y2-y1*y1+x2*x2-x1*x1))/(2.0*((x3-x1)*(y2-y1)-(x2-x1)*(y3-y1))); dl y=((x2-x1)*(x3*x3-x1*x1+y3*y3-y1*y1)-(x3-x1)*(x2*x2-x1*x1+y2*y2-y1*y1))/(2.0*((y3-y1)*(x2-x1)-(y2-y1)*(x3-x1))); ls.push_back(&#123;x,y&#125;);// printf(\"%lf %lf\\n\",x,y); return;&#125; int ans=1,base=0; int cal(int x)&#123; int sum=0; for(int i=1;;i++)&#123; sum+=i; if (x&lt;sum) return i; &#125;&#125; const double eps = 1e-6; bool cmp(pair&lt;dl,dl&gt; a,pair&lt;dl,dl&gt; b)&#123; if (abs(a.first-b.first)&lt;eps) if (abs(a.second-b.second)&lt;eps) return true; return false;&#125; void solve()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld%lld\",&amp;pos[i].x,&amp;pos[i].y); if (pos[i].x==0&amp;&amp;pos[i].y==0)&#123; n--; i--; base++; continue; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123;// printf(\"%d %d: \",i,j); getCenterPos(pos[i].x,pos[i].y,pos[j].x,pos[j].y); &#125; &#125; sort(ls.begin(),ls.end()); pair&lt;dl,dl&gt; pre=&#123;0,0&#125;; int cnt=0; ls.push_back(&#123;0,0&#125;); for(auto x:ls)&#123;// printf(\"%lf %lf\\n\",x.first,x.second); if (cmp(x,pre)==true)&#123; cnt++; &#125; else&#123; ans=max(ans,cal(cnt));// cout&lt;&lt;cnt&lt;&lt;endl; cnt=1; pre=x; &#125; &#125; printf(\"%d\",ans+base);// cout&lt;&lt;base;&#125; int main()&#123;// ios::sync_with_stdio(0);// cin.tie(0),cout.tie(0);// int T;read(T);// for(int i=1;i&lt;=T;i++) solve();&#125; C Cover the Tree根据叶子节点去匹配就好了。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;#define fo(i,a,b) for(int i=a;i&lt;=b;i++)#define read(x) scanf(\"%d\",&amp;x)typedef long long ll;typedef double dl;using namespace std; const int N=3e5+7;const int INF=0x3f3f3f3f; int n,m; int deg[N];int fa[N];int vis[N];int link[N];int ls[N],tot=0;vector&lt;int&gt; G[N]; void dfs(int x)&#123; vis[x]=1; if (deg[x]==1)&#123; ls[++tot]=x; return; &#125; for(auto to:G[x])&#123; if (vis[to]==1) continue; dfs(to); &#125; return;&#125; void out(int a,int b)&#123; if (a&gt;b) swap(a,b); printf(\"%d %d\\n\",a,b);&#125; void solve()&#123; scanf(\"%d\",&amp;n); int u,v; for(int i=1;i&lt;n;i++)&#123; scanf(\"%d%d\",&amp;u,&amp;v); deg[u]++; deg[v]++; G[u].push_back(v); G[v].push_back(u); &#125; for(int i=1;i&lt;=n;i++)&#123; if (deg[i]!=1)&#123; dfs(i); break; &#125; &#125; memset(vis,0,sizeof(vis)); m=(tot+1)/2; printf(\"%d\\n\",m); for(int i=1,j=m+1;i&lt;=tot/2;i++,j+=3)&#123; if (j&gt;tot)&#123; j=m+1; while(vis[j]==1)&#123; j++; &#125; &#125;// cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; vis[i]=vis[j]=1; out(ls[i],ls[j]); &#125; if (tot%2==1) out(ls[1],ls[m]);&#125; int main()&#123;// ios::sync_with_stdio(0);// cin.tie(0),cout.tie(0);// int T;read(T);// for(int i=1;i&lt;=T;i++) solve();&#125; D Duration这个都会。 E Exclusive OR不会 F Fake Maxpooling这个可以用二维RMQ或者二维单调队列去写 详细的blog可以去看 https://www.luogu.com.cn/problem/solution/P2216 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152```#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;deque&gt;#include&lt;vector&gt;#define INF 0x3f3f3f3f#define N 5010#pragma GCC optimize(2)using namespace std;deque&lt;int&gt; Q[N],Q2[N];typedef long long ll;ll mz[N][N];ll mn[N][N],mx[N][N]; int a,b,n;int main() &#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;n); for(int i=1; i&lt;=a; i++) &#123; for(int j=1; j&lt;=b; j++) &#123; mz[i][j]=(1ll)*i/__gcd(i,j)*j; &#125; &#125; for(int i=1; i&lt;=a; i++) &#123; for(int j=1; j&lt;=b; j++) &#123; ll now=mz[i][j]; while(!Q2[i].empty() &amp;&amp; now&gt;=mz[i][Q2[i].back()]) Q2[i].pop_back(); Q2[i].push_back(j); while(Q2[i].back()-Q2[i].front()+1&gt;n) Q2[i].pop_front(); if(j&gt;=n) mx[i][j]=mz[i][Q2[i].front()]; &#125; &#125; ll ans=0; for(int j=n; j&lt;=b; j++) &#123; for(int i=1; i+n-1&lt;=a; i++) &#123; ll mxv=-1; for(int d=0; d&lt;n; d++) mxv=max(mxv,mx[i+d][j]); ans+=mxv; &#125; &#125; printf(\"%lld\\n\",ans); return 0;&#125; G Greater and Greater出题人说看下数据就知道bitset（现在我还不知道为什么要用bitset），就是先用bitset在a[i]中找比b[i]大的数将其为1，顺序要按b[i]的大小，同时记录他们的位置，因为要比b数组都大，所以 满足这样就好了，b在哪个位置，就需要向右移动它本身的位置数-1这样才能满足图片上的匹配，只需要最后统计bitset有多少个1. 1​ #include&lt;bits/stdc++.h&gt; using namespace std; const int MAXN=150010,maxn=40010; bitsetans,w; int a[MAXN],b[maxn];int c[MAXN],p[MAXN];int n,m;inline int cmp1(int x,int y){return a[x]&gt;a[y];}inline int cmp2(int x,int y){return b[x]&gt;b[y];}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],p[i]=i; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i],c[i]=i; sort(p+1,p+1+n,cmp1); sort(c+1,c+1+m,cmp2); int flag=1; ans.set(); for(int i=1;i&lt;=m;i++) { while(a[p[flag]]&gt;=b[c[i]]&amp;&amp;flag&lt;=n) { w[p[flag]]=1; ++flag; } ans=ans&amp;(w&gt;&gt;c[i]-1); } cout&lt;&lt;ans.count();return 0;} 123456## H [Happy Triangle](https://ac.nowcoder.com/acm/contest/5667/H) 这个滑稽姐姐的blog写的挺好的肯定能看懂（ https://www.acwing.com/user/myspace/index/2776/ ）~~~c++ #include&lt;bits/stdc++.h&gt; using namespace std; const int N =2e5+5,inf = 0x3f3f3f3f; vector v;int find(int x){ return lower_bound(v.begin(), v.end(), x) - v.begin();} struct node{ int l,r; int low,h1,h2,b;//low为区间中包含的最小的元素的下标（没有数时为-1） //h1为区间中包含的最大的元素的下标（没有数时为-1） //h2 为区间中包含的次大的元素的下标（没有数时为-1） int sz;//为区间中包含的元素个数}tr[N&lt;&lt;4]; void build(int u,int l,int r){ tr[u]={l,r,-1, -1, -1, inf, 0}; if(l==r) return ; else { int mid=l+r&gt;&gt;1; build(u&lt;&lt;1,l,mid); build(u&lt;&lt;1|1,mid+1,r); }} void pushup(node &amp;u,node &amp;left,node &amp;right){ u.sz=left.sz+right.sz; if(left.sz) u.low=left.low; else u.low=right.low; int h[4]={left.h2,left.h1,right.h1,right.h2}; sort(h,h+4); u.h2=h[2]; u.h1=h[3]; u.b = min(left.b, right.b); if(left.sz and right.sz) u.b=min(u.b,v[right.low]-v[left.h1]);}void pushup(int u){ pushup(tr[u],tr[u&lt;&lt;1],tr[u&lt;&lt;1|1]);} void modify(int u,int x,int c){ if(tr[u].l==x&amp;&amp;tr[u].r==x) { tr[u].sz+=c; if(tr[u].sz&lt;=0){ tr[u].low=-1,tr[u].h1=-1,tr[u].h2=-1; tr[u].b=inf; } else if(tr[u].sz==1) { tr[u].low=x,tr[u].h1=x,tr[u].h2=-1,tr[u].b=inf; } else { tr[u].b=0; tr[u].h1=x,tr[u].h2=x,tr[u].low=x; } return ; } int mid=tr[u].l+tr[u].r&gt;&gt;1; if(x&lt;=mid) modify(u&lt;&lt;1,x,c); else modify(u&lt;&lt;1|1,x,c); pushup(u);}node query(int u,int l,int r){ if(tr[u].l&gt;=l&amp;&amp;tr[u].r&lt;=r) return tr[u]; else { int mid=tr[u].l+tr[u].r&gt;&gt;1; if(r&lt;=mid) return query(u&lt;&lt;1,l,r); else if(l&gt;mid) return query(u&lt;&lt;1|1,l,r); else { auto q1=query(u&lt;&lt;1,l,r); auto q2=query(u&lt;&lt;1|1,l,r); node res; pushup(res,q1,q2); return res; } }} int main(){ int op[N],x[N]; int q; cin&gt;&gt;q; for(int i=1;i&lt;=q;i++) { cin&gt;&gt;op[i]&gt;&gt;x[i]; v.push_back(x[i]); } v.push_back(-1); sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());//离散化； build(1,0,v.size()-1); for(int i=1;i&lt;=q;i++) { if(op[i]==1) { modify(1,find(x[i]),1); continue; } else if(op[i]==2) { modify(1,find(x[i]),-1); continue; } else { node q1=query(1,0,find(x[i])-1); if(q1.sz&gt;=2&amp;&amp;v[q1.h1]+v[q1.h2]&gt;x[i]) { cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; continue; } node q2=query(1,find(x[i]),v.size()-1); if(q2.sz) { q1.b=inf; node res; pushup(res,q1,q2); if(res.b&lt;x[i]) { cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; continue; } } cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; } }}~","path":"2020/07/16/2020牛客暑期多校训练营（第二场）/","date":"07-16","excerpt":"","tags":[{"name":"训练","slug":"训练","permalink":"http://yoursite.com/tags/%E8%AE%AD%E7%BB%83/"}]},{"title":"sort","text":"1.结构体1.只有结构体定义 12345struct node &#123; int a; float b; char job[20];&#125; 2.定义一个结构体变量1node acm; 3.结构体之间的赋值如果我有一个结构体node a，但是我想在定义一个结构体(node b)并且让这个新定义的结构体( b )里面的值都和之前的结构体 a相同 。 12node b;b=a; 4.结构体的引用12345678910struct node &#123;int sorce;char name[20] ;&#125;node chengjidan；int main()&#123; cin&gt;&gt;chengjidan.sorce&gt;&gt;chengjidan.name; cout&lt;&lt;\"name: \"&lt;&lt;chengjidan.name&lt;&lt;endl; cout&lt;&lt;\"sorce: \"&lt;&lt;chengjidan.sorce&lt;&lt;endl;&#125; 5.结构体的运算符重载2.sort简介：sort 排序函数是在 C++ 中的一个库函数，它所在的头文件 为 algrithm.h，它其实就是对快速排序算法的封装，只需要 一行代码即可实现快速排序 它的时间复杂度为 O(n∗log(n)) 形式：sort(参数一, 参数二，参数三） 使用范围: 数组结构体 sting 队列 vector…… 使用方法：对数组 a 从小到大排序 a[5]12345678```\\对数据类型 Y 排序 sort(地址 1，地址 2，less&lt;Y&gt;());//以Y为int为例 int a[5]=&#123;2,1,3,4,5&#125;; sort(a,a+5,less&lt;int&gt;()); //less&lt;int&gt;()升序 //greater&lt;int&gt;()降序 自己定义sort排序自定义排序 1234bool cmp(int a,int b)&#123; return a&lt;b; //从小到大排序 return a&gt;b; //从大到小排序 &#125;sort(a,a+n,cmp) 结构体排序 12345bool cmp1(node a,node b)&#123;//自定义排序函数if(a.grade!=b.grade) return a.grade&gt;b,grade;return a.id&lt;b.id;//按照id排序 ，a&lt;b表示升序 ，a&gt;b降序 &#125; sort(a,a+n,cmp1);&#125; 3.栈和队列栈和队列是一种特殊的线性表，其区别在于栈是先进后出像 一个瓶子，而队列是先进先出像排队 1stack &lt;int&gt; s;//定义一个int型 1s.push(2);// 把2从栈顶压 1s. pop ();//弹出栈顶元素 1s. empty ();//判断栈是否为 空 1s. size ();// 栈的大小 12s.top() ;//返回栈顶的元素，但不删除该元素 1234567q.empty() //如果队列为空返回true，否则返回falseq.size() // 返回队列中元素的个数q.pop() //删除队列首元素但不返回其值q.front() // 返回队首元素的值，但不删除该元素q.push() //在队尾压入新元素q.back() // 返回队列尾元素的值，但不删除该元素","path":"2019/11/17/sort/","date":"11-17","excerpt":"","tags":[{"name":"sort","slug":"sort","permalink":"http://yoursite.com/tags/sort/"}]},{"title":"Kruskal算法求最小生成树（模板）","text":"此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按代价从小到大排序； 把图中的n个顶点看成独立的n棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e5;int f[maxn];struct node &#123; int u;int v;int w;&#125;edges[maxn];bool cmp(node a,node b)&#123; return a.w&lt;b.w; &#125; int find(int x)&#123; if(f[x]!=x) f[x]=find(f[x]); return f[x];&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) f[x]=y;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) f[i]=i; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;edges[i].u&gt;&gt;edges[i].v&gt;&gt;edges[i].w; &#125; sort(edges,edges+m,cmp); int res=0,cnt=0; for(int i=0;i&lt;m;i++) &#123; int a=edges[i].u;int b=edges[i].v;int w=edges[i].w; a=find(a),b=find(b); if(a!=b) &#123; join(a,b); res+=w; cnt++; &#125; &#125; if(cnt &lt; n-1) cout&lt;&lt;\"impossible\"; else cout&lt;&lt;res;&#125;","path":"2019/11/15/s/","date":"11-15","excerpt":"","tags":[{"name":"ACM","slug":"ACM","permalink":"http://yoursite.com/tags/ACM/"}]},{"title":"codeforces 597 div2 的D 题","text":"[Shichikuji and Power Grid]添加链接描述codeforces 597 div2 的D 题，题意：在一个二维平面上面，有n个城市，现在每个城市都没有电。你可以选择一些城市建发电站，代价是c[i]；你也可以给每个城市拉电线，给城市(i,j)之间拉电线的代价是(abs(x[i]-x[j])+abs(y[i]-y[j]))*(k[i]+k[j])。现在问你最少花费多少代价，能够使得全部城市都有电，输出方案。 思路：写的时候无限自闭，最后A了（感谢龙佬），其实思路很简单，就是把这个题变成最小生成树问题就行了，相当于把供电站自身的花费变成了超级远点到供电站的距离，然后套一下最小生成树模板，就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+10;#define ll long long ll f[maxn],r[maxn];typedef pair&lt;ll,ll&gt; pil;struct node &#123; ll x;int y; &#125;p[maxn];struct Node &#123; ll u, v, w;&#125;P[maxn];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;bool cmp2(pil a,pil b)&#123; return a.first &lt;b.first;&#125;ll find(ll x)&#123; return f[x]!=x?f[x]=find(f[x]):x;&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) f[x]=y;&#125; vector&lt;pil&gt; s,ss;int main()&#123; ll n,pos,co; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;co;P[i].u=i;P[i].v=0;P[i].w=co; &#125; for(int i=1;i&lt;=n;i++) cin&gt;&gt;r[i]; pos=n+1; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) &#123; ll mid=(abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y))*(r[i]+r[j]); P[pos].u=j,P[pos].v=i,P[pos++].w=mid; &#125; ll sum=0,a=0,b=0; sort(P+1,P+pos+1,cmp); for(int i=1;i&lt;=pos;i++) &#123; if(find(P[i].u)!=find(P[i].v)) &#123; join(P[i].u,P[i].v); sum+=P[i].w; if(P[i].u!=0&amp;&amp;P[i].v!=0) a++,s.push_back(make_pair(P[i].u,P[i].v)); else b++,ss.push_back(make_pair(P[i].u,P[i].v)); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; sort(ss.begin(),ss.end(),cmp2); for(int i=0;i&lt;ss.size();i++) &#123; ll a1 = ss[i].first, a2 = ss[i].second; if(a1) cout&lt;&lt;a1&lt;&lt;&quot; &quot;; else cout&lt;&lt;a2&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; for(int i=0;i&lt;s.size();i++) &#123; ll a1 = s[i].first, a2 = s[i].second; if (a1 &gt; a2) swap(a1, a2); cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl; &#125;&#125;","path":"2019/11/13/tree/","date":"11-13","excerpt":"","tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"线段树","text":"线段树模板 用于处理区间问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define ll long long#define dl double#define fo(i,a,b) for (int i=a;i&lt;=b;i++)#define println(x)&#123;printf(\":\\n\");for (int tmpi=1;tmpi&lt;=n;tmpi++)printf(\"%d \",x[i]);printf(\"\\n\");&#125;using namespace std;const int N=1e5+7;const int INF=0x3f3f3f3f;const int M=1e9+7;class poi&#123;public: ll l,r,sum,maxx,add,lc,rc;&#125;;class seg&#123;public: vector&lt;poi&gt; s; void bulid(ll x)&#123; if (s[x].lc) return; ll l=s[x].l,r=s[x].r,mid=(l+r)&gt;&gt;1; s.push_back((poi)&#123;l,mid,0,0,0,0,0&#125;); s[x].lc=s.size()-1; s.push_back((poi)&#123;mid+1,r,0,0,0,0,0&#125;); s[x].rc=s.size()-1;&#125;void pushdown(ll x)&#123; bulid(x); ll lc=s[x].lc,rc=s[x].rc; s[lc].add+=s[x].add; s[lc].sum+=s[x].add*(s[lc].r-s[lc].l+1); s[rc].add+=s[x].add; s[rc].sum+=s[x].add*(s[rc].r-s[rc].l+1); updata(x);&#125;void updata(ll x)&#123; s[x].add=0; s[x].sum=s[s[x].lc].sum+s[s[x].rc].sum; s[x].maxx=max(s[s[x].lc].maxx,s[s[x].rc].maxx);&#125;void add(ll x,ll l,ll r,ll t)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; s[x].sum+=t*(s[x].r-s[x].l+1); s[x].add+=t; s[x].maxx+=t; return; &#125; else&#123; pushdown(x); if (l&lt;=s[s[x].lc].r)&#123; add(s[x].lc,l,r,t); &#125; if (r&gt;=s[s[x].rc].l)&#123; add(s[x].rc,l,r,t); &#125; updata(x); &#125;&#125;ll query_sum(ll x,ll l,ll r)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; return s[x].sum; &#125; else&#123; pushdown(x); ll tmp=0; if (l&lt;=s[s[x].lc].r)&#123; tmp+=query_sum(s[x].lc,l,r); &#125; if (r&gt;=s[s[x].rc].l)&#123; tmp+=query_sum(s[x].rc,l,r); &#125; return tmp; &#125;&#125;ll query_max(ll x,ll l,ll r)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; return s[x].maxx; &#125; else&#123; pushdown(x); ll tmp=0; if (l&lt;=s[s[x].lc].r)&#123; tmp=max(tmp,query_max(s[x].lc,l,r)); &#125; if (r&gt;=s[s[x].rc].l)&#123; tmp=max(tmp,query_max(s[x].rc,l,r)); &#125; return tmp; &#125;&#125;&#125;tree;int n;int m;ll l,r,t;ll a;void read()&#123; scanf(\"%d\",&amp;n); tree.s.push_back((poi)&#123;1,n,0,0,0,0&#125;); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;a); tree.add(0,i,i,a); &#125; tree.add(0,1,2,4); cout&lt;&lt;tree.query_max(0,1,4); /*scanf(\"%d\",&amp;m);char ch[5];for (int i=1;i&lt;=m;i++)&#123; scanf(\"%s\",ch); if (ch[0]=='S')&#123; scanf(\"%lld%lld\",&amp;l,&amp;r); printf(\"%lld\\n\",tree.sum(0,l,r)); &#125; if (ch[0]=='A')&#123; scanf(\"%lld%lld%lld\",&amp;l,&amp;r,&amp;t); tree.add(0,l,r,t); &#125;&#125;*/&#125;int main()&#123; read(); return 0;&#125;","path":"2019/11/12/article-name/","date":"11-12","excerpt":"","tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/11/11/hello-world/","date":"11-11","excerpt":"","tags":[]}]}