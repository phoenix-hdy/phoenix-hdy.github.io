{"meta":{"title":"phoenix's blog","subtitle":"phoenix","description":"acm","author":"hdy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"11-11","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-11","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"11-11","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"11-11","excerpt":""}],"posts":[{"title":"codeforces 597 div2 的D 题","text":"[Shichikuji and Power Grid]添加链接描述codeforces 597 div2 的D 题，题意：在一个二维平面上面，有n个城市，现在每个城市都没有电。你可以选择一些城市建发电站，代价是c[i]；你也可以给每个城市拉电线，给城市(i,j)之间拉电线的代价是(abs(x[i]-x[j])+abs(y[i]-y[j]))*(k[i]+k[j])。现在问你最少花费多少代价，能够使得全部城市都有电，输出方案。 思路：写的时候无限自闭，最后A了（感谢龙佬），其实思路很简单，就是把这个题变成最小生成树问题就行了，相当于把供电站自身的花费变成了超级远点到供电站的距离，然后套一下最小生成树模板，就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+10;#define ll long long ll f[maxn],r[maxn];typedef pair&lt;ll,ll&gt; pil;struct node &#123; ll x;int y; &#125;p[maxn];struct Node &#123; ll u, v, w;&#125;P[maxn];bool cmp(Node a,Node b)&#123; return a.w&lt;b.w;&#125;bool cmp2(pil a,pil b)&#123; return a.first &lt;b.first;&#125;ll find(ll x)&#123; return f[x]!=x?f[x]=find(f[x]):x;&#125;void join(int x,int y)&#123; x=find(x); y=find(y); if(x!=y) f[x]=y;&#125; vector&lt;pil&gt; s,ss;int main()&#123; ll n,pos,co; cin&gt;&gt;n; for(int i=0;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) cin&gt;&gt;p[i].x&gt;&gt;p[i].y; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;co;P[i].u=i;P[i].v=0;P[i].w=co; &#125; for(int i=1;i&lt;=n;i++) cin&gt;&gt;r[i]; pos=n+1; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) &#123; ll mid=(abs(p[i].x-p[j].x)+abs(p[i].y-p[j].y))*(r[i]+r[j]); P[pos].u=j,P[pos].v=i,P[pos++].w=mid; &#125; ll sum=0,a=0,b=0; sort(P+1,P+pos+1,cmp); for(int i=1;i&lt;=pos;i++) &#123; if(find(P[i].u)!=find(P[i].v)) &#123; join(P[i].u,P[i].v); sum+=P[i].w; if(P[i].u!=0&amp;&amp;P[i].v!=0) a++,s.push_back(make_pair(P[i].u,P[i].v)); else b++,ss.push_back(make_pair(P[i].u,P[i].v)); &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; sort(ss.begin(),ss.end(),cmp2); for(int i=0;i&lt;ss.size();i++) &#123; ll a1 = ss[i].first, a2 = ss[i].second; if(a1) cout&lt;&lt;a1&lt;&lt;&quot; &quot;; else cout&lt;&lt;a2&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;endl; for(int i=0;i&lt;s.size();i++) &#123; ll a1 = s[i].first, a2 = s[i].second; if (a1 &gt; a2) swap(a1, a2); cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; endl; &#125;&#125;","path":"2019/11/13/tree/","date":"11-13","excerpt":"","tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}]},{"title":"线段树","text":"线段树模板 用于处理区间问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define ll long long#define dl double#define fo(i,a,b) for (int i=a;i&lt;=b;i++)#define println(x)&#123;printf(\":\\n\");for (int tmpi=1;tmpi&lt;=n;tmpi++)printf(\"%d \",x[i]);printf(\"\\n\");&#125;using namespace std;const int N=1e5+7;const int INF=0x3f3f3f3f;const int M=1e9+7;class poi&#123;public: ll l,r,sum,maxx,add,lc,rc;&#125;;class seg&#123;public: vector&lt;poi&gt; s; void bulid(ll x)&#123; if (s[x].lc) return; ll l=s[x].l,r=s[x].r,mid=(l+r)&gt;&gt;1; s.push_back((poi)&#123;l,mid,0,0,0,0,0&#125;); s[x].lc=s.size()-1; s.push_back((poi)&#123;mid+1,r,0,0,0,0,0&#125;); s[x].rc=s.size()-1;&#125;void pushdown(ll x)&#123; bulid(x); ll lc=s[x].lc,rc=s[x].rc; s[lc].add+=s[x].add; s[lc].sum+=s[x].add*(s[lc].r-s[lc].l+1); s[rc].add+=s[x].add; s[rc].sum+=s[x].add*(s[rc].r-s[rc].l+1); updata(x);&#125;void updata(ll x)&#123; s[x].add=0; s[x].sum=s[s[x].lc].sum+s[s[x].rc].sum; s[x].maxx=max(s[s[x].lc].maxx,s[s[x].rc].maxx);&#125;void add(ll x,ll l,ll r,ll t)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; s[x].sum+=t*(s[x].r-s[x].l+1); s[x].add+=t; s[x].maxx+=t; return; &#125; else&#123; pushdown(x); if (l&lt;=s[s[x].lc].r)&#123; add(s[x].lc,l,r,t); &#125; if (r&gt;=s[s[x].rc].l)&#123; add(s[x].rc,l,r,t); &#125; updata(x); &#125;&#125;ll query_sum(ll x,ll l,ll r)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; return s[x].sum; &#125; else&#123; pushdown(x); ll tmp=0; if (l&lt;=s[s[x].lc].r)&#123; tmp+=query_sum(s[x].lc,l,r); &#125; if (r&gt;=s[s[x].rc].l)&#123; tmp+=query_sum(s[x].rc,l,r); &#125; return tmp; &#125;&#125;ll query_max(ll x,ll l,ll r)&#123; if (l&lt;=s[x].l&amp;&amp;s[x].r&lt;=r)&#123; return s[x].maxx; &#125; else&#123; pushdown(x); ll tmp=0; if (l&lt;=s[s[x].lc].r)&#123; tmp=max(tmp,query_max(s[x].lc,l,r)); &#125; if (r&gt;=s[s[x].rc].l)&#123; tmp=max(tmp,query_max(s[x].rc,l,r)); &#125; return tmp; &#125;&#125;&#125;tree;int n;int m;ll l,r,t;ll a;void read()&#123; scanf(\"%d\",&amp;n); tree.s.push_back((poi)&#123;1,n,0,0,0,0&#125;); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;a); tree.add(0,i,i,a); &#125; tree.add(0,1,2,4); cout&lt;&lt;tree.query_max(0,1,4); /*scanf(\"%d\",&amp;m);char ch[5];for (int i=1;i&lt;=m;i++)&#123; scanf(\"%s\",ch); if (ch[0]=='S')&#123; scanf(\"%lld%lld\",&amp;l,&amp;r); printf(\"%lld\\n\",tree.sum(0,l,r)); &#125; if (ch[0]=='A')&#123; scanf(\"%lld%lld%lld\",&amp;l,&amp;r,&amp;t); tree.add(0,l,r,t); &#125;&#125;*/&#125;int main()&#123; read(); return 0;&#125;","path":"2019/11/12/article-name/","date":"11-12","excerpt":"","tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/11/11/hello-world/","date":"11-11","excerpt":"","tags":[]}]}